package org.iutools.sql;

import ca.nrc.datastructure.CloseableIterator;
import ca.nrc.testing.AssertObject;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.sql.SQLException;
import java.util.*;

import static org.iutools.sql.QueryProcessorTest.*;

public class ResultSetWrapperTest {

	private static Row2Person sql2person = new Row2Person();

	@BeforeAll
	public static void beforeAll() throws Exception {
		QueryProcessor processor = new QueryProcessor();
		try {
			PersonSchema schema = new PersonSchema();
			processor.ensureTableIsDefined(schema);
			try (ResultSetWrapper rsw =
				processor.query("DELETE FROM "+schema.tableName)) {
			}
			processor.insertObject(new Person("Homer Simpson"), sql2person);
			processor.insertObject(new Person("Marge Simpson"), sql2person);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
		return;
	}

	@AfterAll
	public static void afterAll() {
		QueryProcessor processor = new QueryProcessor();
		try {
			processor.dropTable(new PersonSchema().tableName);
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}

	////////////////////////////////////////////////////////////////////////////
	// DOCUMENTATION TESTS
	////////////////////////////////////////////////////////////////////////////


	@Test
	public void test__ResultSetIterator__Synopsis() throws Exception {
		// ResultSetIterator allows you to more easily manipulate a ResultSet.
		// Typically, you obtain one as a result of performing an SQL query
		//
		// Note that we use try-with to ensure that wrapper will close all the
		// sql resources generated by the query(), once we are done with it.
		//
		String sql = "SELECT * FROM "+new PersonSchema().tableName;
		try (ResultSetWrapper rsw = new QueryProcessor().query(sql)) {
			// With the rapper, you can do many things, such as:

			// Get the names of all columns in the rows of the set
			List<String> colNames = rsw.colNames();

			// Obtain an iterator that iterates through the ResultSet columns and
			// produces a Plain-old Java object (pojo).
			//
			// Note: We use a try-with so that the iterator will close the SQL
			//   resources when we are done with it.
			//
			//   Also when we create an iterator that way, the wrapper relinquishes
			//   controle over the SQL resources to the iterator. In particular,
			//   the wrapper will not close the SQL resources and will let the
			//   iterator deal with that.
			//
			try (CloseableIterator<Person> personIter = rsw.iterator(new Row2Person())) {
				while (personIter.hasNext()) {
					Person pers = personIter.next();
				}
				// Note: Once we execute the above try-with, the iterator will have closed all the SQL
				//	  resources and the wrapper cannot be used anymore.
			}
		}

		try (ResultSetWrapper rsw = new QueryProcessor().query(sql)){
			// You can generate an iterator that loops through the rows of
			// the ResultSet and returns the value of a single column.
			CloseableIterator<String> nameIter = rsw.colIterator("name", String.class);
			while (nameIter.hasNext()) {
				String name = nameIter.next();
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////
	// VERIFICATION TEST
	////////////////////////////////////////////////////////////////////////////

	@Test
	public void test__IterateThroughPojos__TwoRows() throws Exception {
		String sql = "SELECT * FROM "+new PersonSchema().tableName;
		Person[] expRows = new Person[] {
			new Person("Homer Simpson"),
			new Person("Marge Simpson")
		};

		doIteratePojosTest(
			"Iterating through a two elements ResultSet did not produce the expected results",
			sql, expRows);
	}

	@Test
	public void test__IterateThroughPojos__SingleRow() throws Exception {
		String sql =
			"SELECT * FROM "+new PersonSchema().tableName+"\n"  +
			"WHERE" +
			"  name = 'Homer Simpson'";
		Person[] expRows = new Person[] {
			new Person("Homer Simpson")
		};

		doIteratePojosTest(
			"Iterating through a single elements ResultSet did not produce the expected results",
			sql, expRows);
	}

	@Test
	public void test__IterateThroughPojos__EmptyResults() throws Exception {
		String sql =
			"SELECT * FROM "+new PersonSchema().tableName+"\n"  +
			"WHERE" +
			"  name = 'Charlie Brown'";
		Person[] expRows = new Person[0];

		doIteratePojosTest(
			"Iterating through an empty ResultSet did not produce the expected results",
			sql, expRows);
	}

	@Test
	public void test__IterateThroughColumn__TwoRows() throws Exception {
		String sql = "SELECT * FROM "+new PersonSchema().tableName;
		String[] expColValues = new String[] {
			"Homer Simpson",
			"Marge Simpson"
		};

		doIterateColsTest(
			"Iterating through a two elements ResultSet did not produce the expected results",
			sql, "name", expColValues);
	}

	@Test
	public void test__IterateThroughColumn__SingleRow() throws Exception {
		String sql =
			"SELECT * FROM "+new PersonSchema().tableName+"\n"  +
			"WHERE" +
			"  name = 'Homer Simpson'";
		String[] expNames = new String[] {"Homer Simpson"};

		doIterateColsTest(
			"Iterating through a single elements ResultSet did not produce the expected results",
			sql, "name", expNames);
	}

	@Test
	public void test__IterateThroughColumn__EmptyResults() throws Exception {
		String sql =
			"SELECT * FROM "+new PersonSchema().tableName+"\n"  +
			"WHERE" +
			"  name = 'Charlie Brown'";
		String[] expNames = new String[0];

		doIterateColsTest(
			"Iterating through an empty ResultSet did not produce the expected results",
			sql, "name", expNames);
	}

	////////////////////////////////////////////////////////////////////////////
	// TEST HELPERS
	////////////////////////////////////////////////////////////////////////////

	private void doIteratePojosTest(String mess, String sql, Person[] expRows)
		throws Exception {
		try (ResultSetWrapper rsWrapper = wrapper4query(sql)) {
			CloseableIterator<Person> iter = rsWrapper.iterator(new Row2Person());

			List<Person> gotRows = new ArrayList<Person>();
			while (iter.hasNext()) {
				Person nextPerson = iter.next();
				gotRows.add(nextPerson);
			}
			AssertObject.assertDeepEquals(
				mess + "\nThe rows were not as expected",
				expRows, gotRows);
		}
	}

	private void doIterateColsTest(String mess, String sql, String colName,
		String[] expColValues)
		throws Exception {
		ResultSetWrapper rsWrapper = wrapper4query(sql);
		try (CloseableIterator<String> iter =
				rsWrapper.colIterator(colName,String.class)) {
			List<String> gotColValues = new ArrayList<String>();
			while (iter.hasNext()) {
				String nextColValue = iter.next();
				gotColValues.add(nextColValue);
			}
			AssertObject.assertDeepEquals(
				mess + "\nValues of column "+colName+" were not as expected",
				expColValues, gotColValues);
		}
	}

	private ResultSetWrapper wrapper4query(String sql) throws Exception {
		ResultSetWrapper wrapper = new QueryProcessor().query(sql);
		return wrapper;
	}
}
