package org.iutools.morph;

import ca.nrc.testing.AssertObject;
import ca.nrc.testing.AssertString;
import org.iutools.linguisticdata.LinguisticDataException;
import org.iutools.morph.exp.Decomposition;
import org.junit.Assert;
import org.junit.Test;

import java.util.concurrent.TimeoutException;

import static org.iutools.linguisticdata.Morpheme.MorphFormat;

public class DecompositionTest {

	////////////////////////////////////
	// DOCUMENTATION TESTS
	////////////////////////////////////

	static final String word = "makpigaq";
	static org.iutools.morph.Decomposition decomp = null;

	static {
		try {
			MorphologicalAnalyzer analyzer = new MorphologicalAnalyzer();
			org.iutools.morph.Decomposition[] decompositions = analyzer.decomposeWord(word,false);
			decomp = decompositions[0];
		} catch (LinguisticDataException | TimeoutException | MorphologicalAnalyzerException e) {
			throw new RuntimeException(e);
		}
	}


	@Test
	public void test__Decomposition__Synopsis() throws Exception {

		// At this point, there is not easy way to create a Decomposition
		// directly. Typically, they are generated by a MorphologicalAnalyser.
		String word = "makpigaq";
		MorphologicalAnalyzer analyzer = new MorphologicalAnalyzer();
		org.iutools.morph.Decomposition[] decompositions = analyzer.decomposeWord(word,false);
		org.iutools.morph.Decomposition decomp = decompositions[0];

		// This decomp is more of an "internal" state produced by the analyser
		// You can convert it to a simpler class as follows
		Decomposition simple = decomp.toSimpleDecomposition();

	}

	////////////////////////////////////
	// VERIFICATION TESTS
	////////////////////////////////////

	@Test
	public void test__toSimpleDecomposition() throws Exception {
		org.iutools.morph.exp.Decomposition gotSimple = decomp.toSimpleDecomposition();
		AssertObject.assertDeepEquals(
			"Simple decomp not as expected",
			new org.iutools.morph.exp.Decomposition("makpi:makpiq/1v gaq:gaq/1vn"), gotSimple
		);
	}


	@Test
	public void test__containsMorpheme() throws Exception {
		String word = "makpigaq";
		MorphologicalAnalyzer analyzer = new MorphologicalAnalyzer();
		org.iutools.morph.Decomposition[] decompositions = analyzer.decomposeWord(word,false);
		boolean gotResult = decompositions[0].containsMorpheme("makpiq/1v");
		Assert.assertTrue("", gotResult);
		gotResult = decompositions[0].containsMorpheme("liuq/4nv");
		Assert.assertFalse("", gotResult);
	}
	
	@Test
	public void test__DecompositionExpression_toStringWithoutSurfaceForms() {
		org.iutools.morph.Decomposition.DecompositionExpression expr = new org.iutools.morph.Decomposition.DecompositionExpression("{makpi:makpiq/1v}{gar:gaq/1vn}{ni:ni/tn-loc-p}");
		String exprWithoutSurfaceForms = expr.toStringWithoutSurfaceForms();
		String expected = "{makpiq/1v} {gaq/1vn} {ni/tn-loc-p}";
		Assert.assertEquals("",expected, exprWithoutSurfaceForms);
	}
	
	@Test
	public void test__getSurfaceForms() throws Exception {
		String word = "makpigaq";
		MorphologicalAnalyzer analyzer = new MorphologicalAnalyzer();
		org.iutools.morph.Decomposition[] decompositions = analyzer.decomposeWord(word,false);
		String surfaceForms = String.join(";", decompositions[0].getSurfaceForms().toArray(new String[] {}));
		Assert.assertEquals("",  "makpi;gaq", surfaceForms);
		
		word = "umiarjualiuqti";
		decompositions = analyzer.decomposeWord(word,false);
		surfaceForms = String.join(";", decompositions[0].getSurfaceForms().toArray(new String[] {}));
		Assert.assertEquals("",  "umiar;jua;liuq;ti", surfaceForms);
	}

	@Test
	public void test__formatDecompStr__WITH_BRACES__InputAlreadyHasBraces()
		throws Exception {
		String origDecomp = "{inuk/1n} {tut/1a}";
		new AssertDecomposition(null, "")
			.assertFormattedDecompStrEquals(
				origDecomp, origDecomp, MorphFormat.WITH_BRACES
			);
	}


	@Test
	public void test__formatDecompStr__WITH_BRACES__InputAlreadyHasBracesButWithoutSpaces()
			throws Exception {
		String origDecomp = "{inuk/1n}{tut/1a}";
		String expDecomp = "{inuk/1n} {tut/1a}";
		new AssertDecomposition(null, "")
			.assertFormattedDecompStrEquals(
				expDecomp, origDecomp, MorphFormat.WITH_BRACES
			);
	}

	@Test
	public void test__formatDecompStr__WITH_BRACES__InputDoesNotAlreadyHaveBraces()
			throws Exception {
		String origDecomp = "inuk/1n tut/1a";
		String expFormatted = "{inuk/1n} {tut/1a}";

		new AssertDecomposition(null, "")
			.assertFormattedDecompStrEquals(
				expFormatted, origDecomp, MorphFormat.WITH_BRACES
			);
	}

	@Test
	public void test__formatDecompStr__NO_BRACES__InputHasBraces()
			throws Exception {
		String origDecomp = "{inuk/1n} {tut/1a}";
		String expDecomp = "inuk/1n tut/1a";
		new AssertDecomposition(null, "")
			.assertFormattedDecompStrEquals(
				expDecomp, origDecomp, MorphFormat.NO_BRACES
			);
	}

	@Test
	public void test__formatDecompStr__NO_BRACES__InputDoesNotHaveBraces()
			throws Exception {
		String origDecomp = "inuk/1n tut/1a";
		String expFormatted = "inuk/1n tut/1a";

		new AssertDecomposition(null, "")
			.assertFormattedDecompStrEquals(
				expFormatted, origDecomp, MorphFormat.NO_BRACES
			);
	}

	@Test
	public void test__formatDecompStr__MiscCases() {
		Object[][] cases = new Object[][] {
			new Object[] {
				"{makpi:makpiq/1v}{gaq:gaq/1vn}",
				MorphFormat.NO_BRACES, "makpi:makpiq/1v gaq:gaq/1vn"
			},
			new Object[] {
				"{makpi:makpiq/1v}{gaq:gaq/1vn}",
				MorphFormat.WITH_BRACES, "{makpi:makpiq/1v} {gaq:gaq/1vn}"
			},
			new Object[] {
				"makpi:makpiq/1v gaq:gaq/1vn",
				MorphFormat.WITH_BRACES, "{makpi:makpiq/1v} {gaq:gaq/1vn}"
			},
			new Object[] {
				"makpi:makpiq/1v gaq:gaq/1vn}",
				MorphFormat.NO_BRACES, "makpi:makpiq/1v gaq:gaq/1vn"
			},
		};
		int counter = 0;
		for (Object[] aCase: cases) {
			counter++;
			String decompStr = (String)aCase[0];
			MorphFormat format = (MorphFormat)aCase[1];
			String expFormatted = (String)aCase[2];
			String gotFormatted = org.iutools.morph.Decomposition.formatDecompStr(decompStr, format);
			AssertString.assertStringEquals(
				"Formatting not as expected for case #"+counter+": '"+decompStr+"' with format "+format,
				expFormatted, gotFormatted
			);
		}
	}
}
